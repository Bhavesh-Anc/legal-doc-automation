import { PDFDocument, StandardFonts, rgb } from 'pdf-lib'

interface PDFGeneratorOptions {
  title: string
  content: string
  watermark?: string
  formData?: Record<string, any>
}

export async function generatePDF(options: PDFGeneratorOptions): Promise<Buffer> {
  const { title, content, watermark, formData } = options

  // Create a new PDF document
  const pdfDoc = await PDFDocument.create()

  // Embed fonts
  const timesRomanFont = await pdfDoc.embedFont(StandardFonts.TimesRoman)
  const timesRomanBold = await pdfDoc.embedFont(StandardFonts.TimesRomanBold)

  // Set document metadata
  pdfDoc.setTitle(title)
  pdfDoc.setAuthor('Legal Doc Automation')
  pdfDoc.setCreator('Legal Doc Automation')
  pdfDoc.setProducer('Legal Doc Automation')
  pdfDoc.setCreationDate(new Date())

  // Page setup
  const pageWidth = 612 // 8.5 inches at 72 DPI
  const pageHeight = 792 // 11 inches at 72 DPI
  const margin = 72 // 1 inch margins
  const contentWidth = pageWidth - 2 * margin

  let page = pdfDoc.addPage([pageWidth, pageHeight])
  let yPosition = pageHeight - margin

  const fontSize = 11
  const lineHeight = fontSize * 1.5

  // Helper to add new page when needed
  function checkPageBreak() {
    if (yPosition < margin + 50) {
      page = pdfDoc.addPage([pageWidth, pageHeight])
      yPosition = pageHeight - margin
      return true
    }
    return false
  }

  // Add watermark if this is a trial document
  if (watermark) {
    const watermarkSize = 60
    const opacity = 0.1

    // Add watermark to first page (and we'll add to all pages later)
    page.drawText(watermark, {
      x: pageWidth / 2 - 80,
      y: pageHeight / 2,
      size: watermarkSize,
      font: timesRomanBold,
      color: rgb(0.7, 0.7, 0.7),
      opacity: opacity,
    })
  }

  // Add title
  page.drawText(title.toUpperCase(), {
    x: margin,
    y: yPosition,
    size: 14,
    font: timesRomanBold,
    color: rgb(0, 0, 0),
  })

  yPosition -= lineHeight * 2

  // Add generation date
  const dateText = `Generated: ${new Date().toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
  })}`

  page.drawText(dateText, {
    x: margin,
    y: yPosition,
    size: 9,
    font: timesRomanFont,
    color: rgb(0.3, 0.3, 0.3),
  })

  yPosition -= lineHeight * 2

  // Split content into lines and pages
  const lines = content.split('\n')

  for (const line of lines) {
    checkPageBreak()

    // Handle long lines - wrap text
    const words = line.split(' ')
    let currentLine = ''

    for (const word of words) {
      const testLine = currentLine ? `${currentLine} ${word}` : word
      const textWidth = timesRomanFont.widthOfTextAtSize(testLine, fontSize)

      if (textWidth > contentWidth && currentLine) {
        // Draw current line
        page.drawText(currentLine, {
          x: margin,
          y: yPosition,
          size: fontSize,
          font: timesRomanFont,
          color: rgb(0, 0, 0),
        })

        yPosition -= lineHeight
        checkPageBreak()
        currentLine = word
      } else {
        currentLine = testLine
      }
    }

    // Draw remaining text in current line
    if (currentLine) {
      // Check if line is a header (ALL CAPS or starts with numbers)
      const isHeader =
        currentLine === currentLine.toUpperCase() ||
        /^[IVXLCDM]+\./.test(currentLine) ||
        /^\d+\./.test(currentLine)

      page.drawText(currentLine, {
        x: margin,
        y: yPosition,
        size: fontSize,
        font: isHeader ? timesRomanBold : timesRomanFont,
        color: rgb(0, 0, 0),
      })

      yPosition -= lineHeight
    }
  }

  // Add footer to all pages with disclaimer and branding
  const pages = pdfDoc.getPages()
  const disclaimerText = 'Generated by Legal Doc Automation - Not Legal Advice - Consult an Attorney'
  const brandingText = 'Create your own at legaldocautomation.com | 100% Free'

  pages.forEach((p, index) => {
    // Page number
    p.drawText(`Page ${index + 1} of ${pages.length}`, {
      x: pageWidth / 2 - 40,
      y: 45,
      size: 8,
      font: timesRomanFont,
      color: rgb(0.5, 0.5, 0.5),
    })

    // Disclaimer
    p.drawText(disclaimerText, {
      x: pageWidth / 2 - 200,
      y: 30,
      size: 7,
      font: timesRomanFont,
      color: rgb(0.5, 0.5, 0.5),
    })

    // Powered By branding
    p.drawText(brandingText, {
      x: pageWidth / 2 - 130,
      y: 15,
      size: 8,
      font: timesRomanBold,
      color: rgb(0.2, 0.4, 0.8),
    })

    // Add watermark to all pages if needed
    if (watermark) {
      p.drawText(watermark, {
        x: pageWidth / 2 - 80,
        y: pageHeight / 2,
        size: 60,
        font: timesRomanBold,
        color: rgb(0.7, 0.7, 0.7),
        opacity: 0.1,
      })
    }
  })

  // Serialize the PDF to bytes
  const pdfBytes = await pdfDoc.save()

  return Buffer.from(pdfBytes)
}

// Helper to determine if watermark should be added
export function shouldAddWatermark(subscriptionTier: string): boolean {
  return subscriptionTier === 'trial'
}

// Helper to get watermark text
export function getWatermarkText(subscriptionTier: string): string | undefined {
  return subscriptionTier === 'trial' ? 'TRIAL VERSION' : undefined
}
